#pragma once
#include "loadGraph.h"

class Iterator{
    private:
        Graph graph;
        int numberOfComponents;
        std::vector<Node *> startingComponents;
        bool isEnd;
    public:
        Iterator(Graph gra);
        ~Iterator();


        /**
         * @brief Print all components and its lowest numbers
         * 
         * Print each component of the graph and the node thats used as a starting point for following algorithms
        */
        void PrintInfo();


        /**
         * Resets statuses for all nodes.
        */
        void ResetStatuses();
        

        /**
         * @brief Process graph
         * 
         * Reset function goes trough raw graph and it find all components of it.
         * Also it save the smallest number of each component for later use.
         * It does trough graph by using DFS algorithm.
         * 
         * @param testGraph Raw graph from which the number of components will be calculated
        */
        void Reset(Graph testGrap);


        /**
         * Prints each node's position generated by iterator and also its.
         * 
         * @param id Id of the node
        */
        void CurrentKey(int id);


        /**
         * @brief Checks if stack is empty
         * 
         * processing if the stack, that stores nodes from single component, is empty.
         * If so, it returns TRUE, otherwise its defaulty set as FLASE.
         * 
         * @param st Stack, that stores the components from each component
         * \retval FALSE if stack is not empty
         * \retval TRUE if stack is empty
        */  
        bool IsEnd(std::stack<Node *> st);


        /**
         * @brief Checks is queue is empty
         * 
         * processing if the queue, that stores nodes from single component, is empty.
         * If so, it returns TRUE, otherwise its defaulty set as FLASE.
         * 
         * @param qu Queue, that stores the components from each component
         * \retval FALSE if queue is not empty
         * \retval TRUE if queue is empty
        */
        bool IsEnd(std::queue<Node *> qu);


        /**
         * @brief Depth First Seacrch
         * 
         * DoDFS goes trough graph by using Depth First Search algorithm.
         * The first step is reseting statuses of all nodes to make sure there
         * are no nodes with other status than visited. Then it starts iterating
         * from the smallest number in each node.
         */
        void DoDFS();


        /**
         * @brief Breadth First Search
         * 
         * DoBFS goes trough graph by using Breadth First Search algorithm.
         * The first step is reseting statuses of all nodes to make sure there
         * are no nodes with other status than visited. Then it starts iterating
         * from the smallest number in each node.
         * 
         * @return It prints each node's position generated by iterator and also its ID
        */
        void DoBFS();
};
